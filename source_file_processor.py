
class SourceFileProcessor:

    def __init__(self, config):
        self.snippety = snippety
        self._output_lines = []
        self._inside_directive = False
        self._inside_generated_section = False
        self._current_directive = None
        self.output_start_identifier = config.output_start_identifier
        self.output_end_identifier = config.output_end_identifier
        self.directive_start_identifier = config.directive_start_identifier
        self.directive_end_identifier = config.directive_end_identifier
        self.directive_inline_identifier = config.directive_inline_identifier

    def process_file(self, filepath):
        """Extracts the lines and directives from a file and writes the output
        back to it.
        """
        for line in tuple(open(filepath, "r")):
            # If inside a directive (i.e _current_directive not None)
            # keep adding lines to that directive, unless it is start of new
            # directive, in which case we create a neste directive.
            # Once we've rolled back out of the nested directives, we call
            # _apply_directives, which adds the to the output lines or directs
            # To another file.
            if self._current_directive:
                self._output_lines.append(line)
                if self._line_is_directive_start(line):
                    self._start_directive(line)
                elif self._line_is_inline_directive(line):
                    self._start_directive(line)
                    self._end_current_directive(line)
                elif self._line_is_directive_end(line):
                    self._end_current_directive(line)
                    #If reached end of outtermost directive, apply directives
                    if not self._current_directive:
                        self._apply_directives()
                else:
                    self._current_directive.add_item(line)

            # If inside a generated section, do nothing other than check if
            # we've reached the end
            elif self._inside_generated_section:
                if self._line_is_generated_code_end(line):
                    self._inside_generated_section = False

            # If we're in normal code (not inside a directive or generated
            # section, we just check for starter of sections.
            else:
                if self._line_is_generated_code_start(line):
                    self._inside_generated_section = True
                else:
                    self._output_lines.append(line)
                    if self._line_is_directive_start(line):
                        self._start_directive(line)
                    elif self._line_is_inline_directive(line):
                        self._start_directive(line)
                        self._end_current_directive(line)

        #Fix, here call post-processing, and config for different files
        #Or check if file contents have changed...
        self._write_output(filepath)

    def _line_is_directive_start(self, line):
        line = line.strip()
        return line.startswith(self.directive_start_identifier)

    def _line_is_directive_end(self, line):
        line = line.strip()
        return line == self.directive_end_identifier

    def _line_is_inline_directive(self, line):
        return line.find(self.directive_inline_identifier)

    def _line_is_generated_code_start(self, line):
        line = line.strip()
        return line == self.output_start_identifier

    def _line_is_generated_code_end(self, line):
        line = line.strip()
        return line == self.output_end_identifier

    def _start_directive(self, line):
        assert self._line_is_directive_instruction(line)
        new_directive = Directive(line, self._config)
        if self._current_directive:
            # We're within a directive, so nest it
            self._current_directive.add_item(new_directive)
        else:
            # Not within directive, so set it as to outtermost
            self._outtermost_directive = new_directive
        self._current_directive = new_directive

    def _end_current_directive(self, line):
        assert self._line_is_directive_end(line)
        assert self._current_directive
        # outter_directive may be None, in which case we've reach the end
        self._current_directive = self._current_directive.outter_directive

    def _apply_directives(self):
        """Adds the output generated by the directive to the
        output line.
        Fix: all pre and post processing, as well as output to other file.
        """
        self._outtermost_directive.add_to_output_lines(self._output_lines)
        self._outtermost_directive = None

    def _write_output(self, output_path):
        file = open(output_path, 'w')
        file.writelines(self._output_lines)
        file.close()
